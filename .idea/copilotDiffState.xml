<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/D0828/two/StockDataProcessor.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/D0828/two/StockDataProcessor.java" />
              <option name="originalContent" value="package D0828.two;&#10;&#10;import javax.swing.*;&#10;import javax.swing.table.DefaultTableModel;&#10;import java.awt.*;&#10;import java.awt.event.ActionEvent;&#10;import java.awt.event.ActionListener;&#10;import java.io.*;&#10;import java.text.ParseException;&#10;import java.text.SimpleDateFormat;&#10;import java.util.*;&#10;import java.util.List;&#10;import java.util.regex.Pattern;&#10;&#10;// Custom class to hold stock data&#10;class StockData {&#10;    String symbol;&#10;    String date; // yyyy/MM/dd&#10;    String time; // HH:mm:ss&#10;    double open;&#10;    double high;&#10;    double low;&#10;    double close;&#10;    long volume;&#10;&#10;    public StockData(String symbol, String date, String time, double open, double high, double low, double close, long volume) {&#10;        this.symbol = symbol;&#10;        this.date = date;&#10;        this.time = time;&#10;        this.open = open;&#10;        this.high = high;&#10;        this.low = low;&#10;        this.close = close;&#10;        this.volume = volume;&#10;    }&#10;&#10;    // For display purposes&#10;    @Override&#10;    public String toString() {&#10;        return symbol + &quot;,&quot; + date + &quot;,&quot; + time + &quot;,&quot; + open + &quot;,&quot; + high + &quot;,&quot; + low + &quot;,&quot; + close + &quot;,&quot; + volume;&#10;    }&#10;}&#10;&#10;// Main application class&#10;public class StockDataProcessor extends JFrame {&#10;    private HashMap&lt;String, List&lt;StockData&gt;&gt; dataMap = new HashMap&lt;&gt;();&#10;    private JTable displayTable;&#10;    private DefaultTableModel tableModel;&#10;    private JTextField dateField, startDateField, endDateField, lengthField, singleDateTimeField, rangeDateStartTimeField, rangeDateEndTimeField;&#10;    private JTextArea outputArea;&#10;    private List&lt;StockData&gt; currentQueryResults = new ArrayList&lt;&gt;(); // To hold results for export&#10;&#10;    public StockDataProcessor() {&#10;        setTitle(&quot;Taiwan Stock Minute Data Processor&quot;);&#10;        setSize(800, 600);&#10;        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#10;        setLayout(new BorderLayout());&#10;&#10;        // Menu for loading file&#10;        JMenuBar menuBar = new JMenuBar();&#10;        JMenu fileMenu = new JMenu(&quot;File&quot;);&#10;        JMenuItem loadItem = new JMenuItem(&quot;Load CSV&quot;);&#10;        loadItem.addActionListener(new LoadFileListener());&#10;        fileMenu.add(loadItem);&#10;        menuBar.add(fileMenu);&#10;        setJMenuBar(menuBar);&#10;&#10;        // Panel for inputs&#10;        JPanel inputPanel = new JPanel(new GridLayout(0, 2));&#10;&#10;        // Function 3: Single day query&#10;        inputPanel.add(new JLabel(&quot;Single Date (yyyy/MM/dd):&quot;));&#10;        dateField = new JTextField();&#10;        inputPanel.add(dateField);&#10;        JButton singleDayBtn = new JButton(&quot;Query Single Day&quot;);&#10;        singleDayBtn.addActionListener(new SingleDayQueryListener());&#10;        inputPanel.add(singleDayBtn);&#10;&#10;        // Function 4: Multi-day query&#10;        inputPanel.add(new JLabel(&quot;Start Date (yyyy/MM/dd):&quot;));&#10;        startDateField = new JTextField();&#10;        inputPanel.add(startDateField);&#10;        inputPanel.add(new JLabel(&quot;End Date (yyyy/MM/dd) or Length (days):&quot;));&#10;        endDateField = new JTextField();&#10;        lengthField = new JTextField();&#10;        inputPanel.add(endDateField);&#10;        inputPanel.add(new JLabel(&quot;Use Length instead? Enter here:&quot;));&#10;        inputPanel.add(lengthField);&#10;        JButton multiDayBtn = new JButton(&quot;Query Multi Days&quot;);&#10;        multiDayBtn.addActionListener(new MultiDayQueryListener());&#10;        inputPanel.add(multiDayBtn);&#10;&#10;        // Function 5: Single date + time&#10;        inputPanel.add(new JLabel(&quot;Date + Time (yyyy/MM/dd HH:mm:ss):&quot;));&#10;        singleDateTimeField = new JTextField();&#10;        inputPanel.add(singleDateTimeField);&#10;        JButton singleTimeBtn = new JButton(&quot;Query Single Time&quot;);&#10;        singleTimeBtn.addActionListener(new SingleTimeQueryListener());&#10;        inputPanel.add(singleTimeBtn);&#10;&#10;        // Function 6: Date + time range&#10;        inputPanel.add(new JLabel(&quot;Start Date + Time (yyyy/MM/dd HH:mm:ss):&quot;));&#10;        rangeDateStartTimeField = new JTextField();&#10;        inputPanel.add(rangeDateStartTimeField);&#10;        inputPanel.add(new JLabel(&quot;End Date + Time (yyyy/MM/dd HH:mm:ss):&quot;));&#10;        rangeDateEndTimeField = new JTextField();&#10;        inputPanel.add(rangeDateEndTimeField);&#10;        JButton rangeTimeBtn = new JButton(&quot;Query Time Range&quot;);&#10;        rangeTimeBtn.addActionListener(new TimeRangeQueryListener());&#10;        inputPanel.add(rangeTimeBtn);&#10;&#10;        // Function 7: Export&#10;        JButton exportBtn = new JButton(&quot;Export Current Results to CSV&quot;);&#10;        exportBtn.addActionListener(new ExportListener());&#10;        inputPanel.add(exportBtn);&#10;&#10;        add(inputPanel, BorderLayout.NORTH);&#10;&#10;        // Table for displaying data&#10;        tableModel = new DefaultTableModel(new String[]{&quot;Symbol&quot;, &quot;Date&quot;, &quot;Time&quot;, &quot;Open&quot;, &quot;High&quot;, &quot;Low&quot;, &quot;Close&quot;, &quot;Volume&quot;}, 0);&#10;        displayTable = new JTable(tableModel);&#10;        add(new JScrollPane(displayTable), BorderLayout.CENTER);&#10;&#10;        // Text area for aggregated results (for func 5 &amp; 6)&#10;        outputArea = new JTextArea();&#10;        outputArea.setEditable(false);&#10;        add(new JScrollPane(outputArea), BorderLayout.SOUTH);&#10;&#10;        setVisible(true);&#10;    }&#10;&#10;    // Normalize date to yyyy/MM/dd&#10;    private String normalizeDate(String date) {&#10;        String[] parts = date.split(Pattern.quote(&quot;/&quot;));&#10;        if (parts.length == 3) {&#10;            return String.format(&quot;%04d/%02d/%02d&quot;, Integer.parseInt(parts[0]), Integer.parseInt(parts[1]), Integer.parseInt(parts[2]));&#10;        }&#10;        return date;&#10;    }&#10;&#10;    // Load CSV file&#10;    class LoadFileListener implements ActionListener {&#10;        @Override&#10;        public void actionPerformed(ActionEvent e) {&#10;            JFileChooser fc = new JFileChooser();&#10;            if (fc.showOpenDialog(null) == JFileChooser.APPROVE_OPTION) {&#10;                File file = fc.getSelectedFile();&#10;                try (BufferedReader br = new BufferedReader(new FileReader(file))) {&#10;                    String line;&#10;                    br.readLine(); // Skip header&#10;                    while ((line = br.readLine()) != null) {&#10;                        if (line.trim().isEmpty()) continue;&#10;                        String[] parts = line.split(&quot;,&quot;);&#10;                        if (parts.length &lt; 8) continue;&#10;                        String symbol = parts[0].trim();&#10;                        String date = normalizeDate(parts[1].trim());&#10;                        String time = parts[2].trim();&#10;                        double open = Double.parseDouble(parts[3].trim());&#10;                        double high = Double.parseDouble(parts[4].trim());&#10;                        double low = Double.parseDouble(parts[5].trim());&#10;                        double close = Double.parseDouble(parts[6].trim());&#10;                        long volume = Long.parseLong(parts[7].trim());&#10;&#10;                        StockData data = new StockData(symbol, date, time, open, high, low, close, volume);&#10;                        dataMap.computeIfAbsent(date, k -&gt; new ArrayList&lt;&gt;()).add(data);&#10;                    }&#10;                    // Sort each day's list by time&#10;                    for (List&lt;StockData&gt; list : dataMap.values()) {&#10;                        list.sort(Comparator.comparing(d -&gt; d.time));&#10;                    }&#10;                    JOptionPane.showMessageDialog(null, &quot;Data loaded successfully!&quot;);&#10;                } catch (IOException | NumberFormatException ex) {&#10;                    JOptionPane.showMessageDialog(null, &quot;Error loading file: &quot; + ex.getMessage());&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Function 3: Single day query&#10;    class SingleDayQueryListener implements ActionListener {&#10;        @Override&#10;        public void actionPerformed(ActionEvent e) {&#10;            String date = normalizeDate(dateField.getText().trim());&#10;            List&lt;StockData&gt; data = dataMap.get(date);&#10;            displayData(data);&#10;        }&#10;    }&#10;&#10;    // Function 4: Multi-day query&#10;    class MultiDayQueryListener implements ActionListener {&#10;        @Override&#10;        public void actionPerformed(ActionEvent e) {&#10;            String startDateStr = normalizeDate(startDateField.getText().trim());&#10;            List&lt;StockData&gt; results = new ArrayList&lt;&gt;();&#10;            SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy/MM/dd&quot;);&#10;            try {&#10;                Date startDate = sdf.parse(startDateStr);&#10;                Calendar cal = Calendar.getInstance();&#10;                cal.setTime(startDate);&#10;&#10;                if (!endDateField.getText().trim().isEmpty()) {&#10;                    String endDateStr = normalizeDate(endDateField.getText().trim());&#10;                    Date endDate = sdf.parse(endDateStr);&#10;                    while (!cal.getTime().after(endDate)) {&#10;                        String curDate = sdf.format(cal.getTime());&#10;                        if (dataMap.containsKey(curDate)) {&#10;                            results.addAll(dataMap.get(curDate));&#10;                        }&#10;                        cal.add(Calendar.DAY_OF_MONTH, 1);&#10;                    }&#10;                } else if (!lengthField.getText().trim().isEmpty()) {&#10;                    int length = Integer.parseInt(lengthField.getText().trim());&#10;                    for (int i = 0; i &lt; length; i++) {&#10;                        String curDate = sdf.format(cal.getTime());&#10;                        if (dataMap.containsKey(curDate)) {&#10;                            results.addAll(dataMap.get(curDate));&#10;                        }&#10;                        cal.add(Calendar.DAY_OF_MONTH, 1);&#10;                    }&#10;                }&#10;                displayData(results);&#10;            } catch (ParseException | NumberFormatException ex) {&#10;                JOptionPane.showMessageDialog(null, &quot;Invalid date or length: &quot; + ex.getMessage());&#10;            }&#10;        }&#10;    }&#10;&#10;    // Function 5: Single date + time&#10;    class SingleTimeQueryListener implements ActionListener {&#10;        @Override&#10;        public void actionPerformed(ActionEvent e) {&#10;            String input = singleDateTimeField.getText().trim();&#10;            String[] parts = input.split(&quot; &quot;);&#10;            if (parts.length != 2) return;&#10;            String date = normalizeDate(parts[0]);&#10;            String time = parts[1];&#10;            List&lt;StockData&gt; dayData = dataMap.get(date);&#10;            if (dayData != null) {&#10;                for (StockData data : dayData) {&#10;                    if (data.time.equals(time)) {&#10;                        outputArea.setText(&quot;Open: &quot; + data.open + &quot;\nHigh: &quot; + data.high + &quot;\nLow: &quot; + data.low + &quot;\nClose: &quot; + data.close + &quot;\nVolume: &quot; + data.volume);&#10;                        currentQueryResults.clear();&#10;                        currentQueryResults.add(data);&#10;                        tableModel.setRowCount(0); // Clear table for aggregated view&#10;                        return;&#10;                    }&#10;                }&#10;            }&#10;            outputArea.setText(&quot;No data found for &quot; + input);&#10;        }&#10;    }&#10;&#10;    // Function 6: Date + time range (aggregated OHLCV)&#10;    class TimeRangeQueryListener implements ActionListener {&#10;        @Override&#10;        public void actionPerformed(ActionEvent e) {&#10;            String startInput = rangeDateStartTimeField.getText().trim();&#10;            String endInput = rangeDateEndTimeField.getText().trim();&#10;            String[] startParts = startInput.split(&quot; &quot;);&#10;            String[] endParts = endInput.split(&quot; &quot;);&#10;            if (startParts.length != 2 || endParts.length != 2) return;&#10;            String startDate = normalizeDate(startParts[0]);&#10;            String startTime = startParts[1];&#10;            String endDate = normalizeDate(endParts[0]);&#10;            String endTime = endParts[1];&#10;&#10;            List&lt;StockData&gt; rangeData = getDataInRange(startDate, startTime, endDate, endTime);&#10;            if (!rangeData.isEmpty()) {&#10;                double open = rangeData.get(0).open;&#10;                double high = rangeData.stream().mapToDouble(d -&gt; d.high).max().getAsDouble();&#10;                double low = rangeData.stream().mapToDouble(d -&gt; d.low).min().getAsDouble();&#10;                double close = rangeData.get(rangeData.size() - 1).close;&#10;                long volume = rangeData.stream().mapToLong(d -&gt; d.volume).sum();&#10;&#10;                outputArea.setText(&quot;Aggregated:\nOpen: &quot; + open + &quot;\nHigh: &quot; + high + &quot;\nLow: &quot; + low + &quot;\nClose: &quot; + close + &quot;\nVolume: &quot; + volume);&#10;                currentQueryResults = rangeData; // For export, keep full list&#10;                displayData(rangeData); // Display full list in table&#10;            } else {&#10;                outputArea.setText(&quot;No data in range&quot;);&#10;            }&#10;        }&#10;    }&#10;&#10;    // Helper to get data in time range (assuming single day for simplicity, extend if needed)&#10;    private List&lt;StockData&gt; getDataInRange(String startDate, String startTime, String endDate, String endTime) {&#10;        List&lt;StockData&gt; results = new ArrayList&lt;&gt;();&#10;        if (!startDate.equals(endDate)) {&#10;            // For multi-day, but for simplicity, assume same day or handle sequentially&#10;            // Implement multi-day if needed, but query implies same date&#10;            return results; // Placeholder, extend as per need&#10;        }&#10;        List&lt;StockData&gt; dayData = dataMap.get(startDate);&#10;        if (dayData != null) {&#10;            boolean started = false;&#10;            for (StockData data : dayData) {&#10;                if (!started &amp;&amp; data.time.compareTo(startTime) &gt;= 0) {&#10;                    started = true;&#10;                }&#10;                if (started) {&#10;                    results.add(data);&#10;                    if (data.time.compareTo(endTime) &gt; 0) {&#10;                        results.remove(results.size() - 1); // Exclude if beyond&#10;                        break;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return results;&#10;    }&#10;&#10;    // Display list in table&#10;    private void displayData(List&lt;StockData&gt; data) {&#10;        tableModel.setRowCount(0);&#10;        outputArea.setText(&quot;&quot;);&#10;        if (data != null) {&#10;            for (StockData d : data) {&#10;                tableModel.addRow(new Object[]{d.symbol, d.date, d.time, d.open, d.high, d.low, d.close, d.volume});&#10;            }&#10;            currentQueryResults = data;&#10;        }&#10;    }&#10;&#10;    // Function 7: Export to CSV (all fields for now, can add selection later)&#10;    class ExportListener implements ActionListener {&#10;        @Override&#10;        public void actionPerformed(ActionEvent e) {&#10;            if (currentQueryResults.isEmpty()) {&#10;                JOptionPane.showMessageDialog(null, &quot;No data to export&quot;);&#10;                return;&#10;            }&#10;            JFileChooser fc = new JFileChooser();&#10;            if (fc.showSaveDialog(null) == JFileChooser.APPROVE_OPTION) {&#10;                File file = fc.getSelectedFile();&#10;                try (BufferedWriter bw = new BufferedWriter(new FileWriter(file))) {&#10;                    bw.write(&quot;Symbol,Date,Time,Open,High,Low,Close,Volume\n&quot;);&#10;                    for (StockData d : currentQueryResults) {&#10;                        bw.write(d.toString() + &quot;\n&quot;);&#10;                    }&#10;                    JOptionPane.showMessageDialog(null, &quot;Exported successfully!&quot;);&#10;                } catch (IOException ex) {&#10;                    JOptionPane.showMessageDialog(null, &quot;Error exporting: &quot; + ex.getMessage());&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        SwingUtilities.invokeLater(StockDataProcessor::new);&#10;    }&#10;}" />
              <option name="updatedContent" value="package D0828.two;&#10;&#10;import javax.swing.*;&#10;import javax.swing.table.DefaultTableModel;&#10;import java.awt.*;&#10;import java.awt.event.ActionEvent;&#10;import java.awt.event.ActionListener;&#10;import java.io.*;&#10;import java.text.ParseException;&#10;import java.text.SimpleDateFormat;&#10;import java.util.*;&#10;import java.util.List;&#10;import java.util.regex.Pattern;&#10;&#10;// Custom class to hold stock data&#10;class StockData {&#10;    String symbol;&#10;    String date; // yyyy/MM/dd&#10;    String time; // HH:mm:ss&#10;    double open;&#10;    double high;&#10;    double low;&#10;    double close;&#10;    long volume;&#10;&#10;    public StockData(String symbol, String date, String time, double open, double high, double low, double close, long volume) {&#10;        this.symbol = symbol;&#10;        this.date = date;&#10;        this.time = time;&#10;        this.open = open;&#10;        this.high = high;&#10;        this.low = low;&#10;        this.close = close;&#10;        this.volume = volume;&#10;    }&#10;&#10;    // For display purposes&#10;    @Override&#10;    public String toString() {&#10;        return symbol + &quot;,&quot; + date + &quot;,&quot; + time + &quot;,&quot; + open + &quot;,&quot; + high + &quot;,&quot; + low + &quot;,&quot; + close + &quot;,&quot; + volume;&#10;    }&#10;}&#10;&#10;// Main application class&#10;public class StockDataProcessor extends JFrame {&#10;    private HashMap&lt;String, List&lt;StockData&gt;&gt; dataMap = new HashMap&lt;&gt;();&#10;    private JTable displayTable;&#10;    private DefaultTableModel tableModel;&#10;    private JTextField dateField, startDateField, endDateField, lengthField, singleDateTimeField, rangeDateStartTimeField, rangeDateEndTimeField;&#10;    private JTextArea outputArea;&#10;    private List&lt;StockData&gt; currentQueryResults = new ArrayList&lt;&gt;(); // To hold results for export&#10;&#10;    public StockDataProcessor() {&#10;        setTitle(&quot;臺灣股票分鐘資料處理器&quot;);&#10;        setSize(900, 700);&#10;        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#10;        setLayout(new BorderLayout());&#10;&#10;        // Menu for loading file&#10;        JMenuBar menuBar = new JMenuBar();&#10;        JMenu fileMenu = new JMenu(&quot;檔案&quot;);&#10;        JMenuItem loadItem = new JMenuItem(&quot;載入 CSV&quot;);&#10;        loadItem.addActionListener(new LoadFileListener());&#10;        fileMenu.add(loadItem);&#10;        menuBar.add(fileMenu);&#10;        setJMenuBar(menuBar);&#10;&#10;        // Panel for inputs&#10;        JPanel inputPanel = new JPanel(new GridLayout(0, 2, 10, 5));&#10;        inputPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));&#10;&#10;        // Function 3: Single day query&#10;        inputPanel.add(new JLabel(&quot;單一日期 (yyyy/MM/dd):&quot;));&#10;        dateField = new JTextField();&#10;        inputPanel.add(dateField);&#10;        JButton singleDayBtn = new JButton(&quot;查詢單一日期&quot;);&#10;        singleDayBtn.addActionListener(new SingleDayQueryListener());&#10;        inputPanel.add(singleDayBtn);&#10;        inputPanel.add(new JLabel(&quot;&quot;)); // 空白佔位&#10;&#10;        // Function 4: Multi-day query&#10;        inputPanel.add(new JLabel(&quot;開始日期 (yyyy/MM/dd):&quot;));&#10;        startDateField = new JTextField();&#10;        inputPanel.add(startDateField);&#10;        inputPanel.add(new JLabel(&quot;結束日期 (yyyy/MM/dd):&quot;));&#10;        endDateField = new JTextField();&#10;        inputPanel.add(endDateField);&#10;        inputPanel.add(new JLabel(&quot;或使用天數:&quot;));&#10;        lengthField = new JTextField();&#10;        inputPanel.add(lengthField);&#10;        JButton multiDayBtn = new JButton(&quot;查詢多日資料&quot;);&#10;        multiDayBtn.addActionListener(new MultiDayQueryListener());&#10;        inputPanel.add(multiDayBtn);&#10;        inputPanel.add(new JLabel(&quot;&quot;)); // 空白佔位&#10;&#10;        // Function 5: Single date + time&#10;        inputPanel.add(new JLabel(&quot;日期時間 (yyyy/MM/dd HH:mm:ss):&quot;));&#10;        singleDateTimeField = new JTextField();&#10;        inputPanel.add(singleDateTimeField);&#10;        JButton singleTimeBtn = new JButton(&quot;查詢單一時間點&quot;);&#10;        singleTimeBtn.addActionListener(new SingleTimeQueryListener());&#10;        inputPanel.add(singleTimeBtn);&#10;        inputPanel.add(new JLabel(&quot;&quot;)); // 空白佔位&#10;&#10;        // Function 6: Date + time range&#10;        inputPanel.add(new JLabel(&quot;開始日期時間 (yyyy/MM/dd HH:mm:ss):&quot;));&#10;        rangeDateStartTimeField = new JTextField();&#10;        inputPanel.add(rangeDateStartTimeField);&#10;        inputPanel.add(new JLabel(&quot;結束日期時間 (yyyy/MM/dd HH:mm:ss):&quot;));&#10;        rangeDateEndTimeField = new JTextField();&#10;        inputPanel.add(rangeDateEndTimeField);&#10;        JButton rangeTimeBtn = new JButton(&quot;查詢時間範圍&quot;);&#10;        rangeTimeBtn.addActionListener(new TimeRangeQueryListener());&#10;        inputPanel.add(rangeTimeBtn);&#10;        inputPanel.add(new JLabel(&quot;&quot;)); // 空白佔位&#10;&#10;        // Function 7: Export&#10;        JButton exportBtn = new JButton(&quot;匯出目前結果至 CSV&quot;);&#10;        exportBtn.addActionListener(new ExportListener());&#10;        inputPanel.add(exportBtn);&#10;&#10;        add(inputPanel, BorderLayout.NORTH);&#10;&#10;        // Table for displaying data&#10;        tableModel = new DefaultTableModel(new String[]{&quot;股票代號&quot;, &quot;日期&quot;, &quot;時間&quot;, &quot;開盤價&quot;, &quot;最高價&quot;, &quot;最低價&quot;, &quot;收盤價&quot;, &quot;成交量&quot;}, 0);&#10;        displayTable = new JTable(tableModel);&#10;        displayTable.setFont(new Font(&quot;微軟正黑體&quot;, Font.PLAIN, 14));&#10;        displayTable.getTableHeader().setFont(new Font(&quot;微軟正黑體&quot;, Font.BOLD, 14));&#10;        add(new JScrollPane(displayTable), BorderLayout.CENTER);&#10;&#10;        // Text area for aggregated results (for func 5 &amp; 6)&#10;        outputArea = new JTextArea(5, 20);&#10;        outputArea.setEditable(false);&#10;        outputArea.setFont(new Font(&quot;微軟正黑體&quot;, Font.PLAIN, 14));&#10;        add(new JScrollPane(outputArea), BorderLayout.SOUTH);&#10;&#10;        setVisible(true);&#10;    }&#10;&#10;    // Normalize date to yyyy/MM/dd&#10;    private String normalizeDate(String date) {&#10;        String[] parts = date.split(Pattern.quote(&quot;/&quot;));&#10;        if (parts.length == 3) {&#10;            return String.format(&quot;%04d/%02d/%02d&quot;, Integer.parseInt(parts[0]), Integer.parseInt(parts[1]), Integer.parseInt(parts[2]));&#10;        }&#10;        return date;&#10;    }&#10;&#10;    // Load CSV file&#10;    class LoadFileListener implements ActionListener {&#10;        @Override&#10;        public void actionPerformed(ActionEvent e) {&#10;            JFileChooser fc = new JFileChooser();&#10;            if (fc.showOpenDialog(null) == JFileChooser.APPROVE_OPTION) {&#10;                File file = fc.getSelectedFile();&#10;                try (BufferedReader br = new BufferedReader(new FileReader(file))) {&#10;                    String line;&#10;                    br.readLine(); // Skip header&#10;                    while ((line = br.readLine()) != null) {&#10;                        if (line.trim().isEmpty()) continue;&#10;                        String[] parts = line.split(&quot;,&quot;);&#10;                        if (parts.length &lt; 8) continue;&#10;                        String symbol = parts[0].trim();&#10;                        String date = normalizeDate(parts[1].trim());&#10;                        String time = parts[2].trim();&#10;                        double open = Double.parseDouble(parts[3].trim());&#10;                        double high = Double.parseDouble(parts[4].trim());&#10;                        double low = Double.parseDouble(parts[5].trim());&#10;                        double close = Double.parseDouble(parts[6].trim());&#10;                        long volume = Long.parseLong(parts[7].trim());&#10;&#10;                        StockData data = new StockData(symbol, date, time, open, high, low, close, volume);&#10;                        dataMap.computeIfAbsent(date, k -&gt; new ArrayList&lt;&gt;()).add(data);&#10;                    }&#10;                    // Sort each day's list by time&#10;                    for (List&lt;StockData&gt; list : dataMap.values()) {&#10;                        list.sort(Comparator.comparing(d -&gt; d.time));&#10;                    }&#10;                    JOptionPane.showMessageDialog(null, &quot;資料載入成功！&quot;);&#10;                } catch (IOException | NumberFormatException ex) {&#10;                    JOptionPane.showMessageDialog(null, &quot;載入檔案時發生錯誤: &quot; + ex.getMessage());&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Function 3: Single day query&#10;    class SingleDayQueryListener implements ActionListener {&#10;        @Override&#10;        public void actionPerformed(ActionEvent e) {&#10;            String date = normalizeDate(dateField.getText().trim());&#10;            List&lt;StockData&gt; data = dataMap.get(date);&#10;            displayData(data);&#10;        }&#10;    }&#10;&#10;    // Function 4: Multi-day query&#10;    class MultiDayQueryListener implements ActionListener {&#10;        @Override&#10;        public void actionPerformed(ActionEvent e) {&#10;            String startDateStr = normalizeDate(startDateField.getText().trim());&#10;            List&lt;StockData&gt; results = new ArrayList&lt;&gt;();&#10;            SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy/MM/dd&quot;);&#10;            try {&#10;                Date startDate = sdf.parse(startDateStr);&#10;                Calendar cal = Calendar.getInstance();&#10;                cal.setTime(startDate);&#10;&#10;                if (!endDateField.getText().trim().isEmpty()) {&#10;                    String endDateStr = normalizeDate(endDateField.getText().trim());&#10;                    Date endDate = sdf.parse(endDateStr);&#10;                    while (!cal.getTime().after(endDate)) {&#10;                        String curDate = sdf.format(cal.getTime());&#10;                        if (dataMap.containsKey(curDate)) {&#10;                            results.addAll(dataMap.get(curDate));&#10;                        }&#10;                        cal.add(Calendar.DAY_OF_MONTH, 1);&#10;                    }&#10;                } else if (!lengthField.getText().trim().isEmpty()) {&#10;                    int length = Integer.parseInt(lengthField.getText().trim());&#10;                    for (int i = 0; i &lt; length; i++) {&#10;                        String curDate = sdf.format(cal.getTime());&#10;                        if (dataMap.containsKey(curDate)) {&#10;                            results.addAll(dataMap.get(curDate));&#10;                        }&#10;                        cal.add(Calendar.DAY_OF_MONTH, 1);&#10;                    }&#10;                }&#10;                displayData(results);&#10;            } catch (ParseException | NumberFormatException ex) {&#10;                JOptionPane.showMessageDialog(null, &quot;無效的日期或天數: &quot; + ex.getMessage());&#10;            }&#10;        }&#10;    }&#10;&#10;    // Function 5: Single date + time&#10;    class SingleTimeQueryListener implements ActionListener {&#10;        @Override&#10;        public void actionPerformed(ActionEvent e) {&#10;            String input = singleDateTimeField.getText().trim();&#10;            String[] parts = input.split(&quot; &quot;);&#10;            if (parts.length != 2) return;&#10;            String date = normalizeDate(parts[0]);&#10;            String time = parts[1];&#10;            List&lt;StockData&gt; dayData = dataMap.get(date);&#10;            if (dayData != null) {&#10;                for (StockData data : dayData) {&#10;                    if (data.time.equals(time)) {&#10;                        outputArea.setText(&quot;開盤價: &quot; + data.open + &quot;\n最高價: &quot; + data.high + &quot;\n最低價: &quot; + data.low + &quot;\n收盤價: &quot; + data.close + &quot;\n成交量: &quot; + data.volume);&#10;                        currentQueryResults.clear();&#10;                        currentQueryResults.add(data);&#10;                        tableModel.setRowCount(0); // Clear table for aggregated view&#10;                        return;&#10;                    }&#10;                }&#10;            }&#10;            outputArea.setText(&quot;找不到 &quot; + input + &quot; 的資料&quot;);&#10;        }&#10;    }&#10;&#10;    // Function 6: Date + time range (aggregated OHLCV)&#10;    class TimeRangeQueryListener implements ActionListener {&#10;        @Override&#10;        public void actionPerformed(ActionEvent e) {&#10;            String startInput = rangeDateStartTimeField.getText().trim();&#10;            String endInput = rangeDateEndTimeField.getText().trim();&#10;            String[] startParts = startInput.split(&quot; &quot;);&#10;            String[] endParts = endInput.split(&quot; &quot;);&#10;            if (startParts.length != 2 || endParts.length != 2) return;&#10;            String startDate = normalizeDate(startParts[0]);&#10;            String startTime = startParts[1];&#10;            String endDate = normalizeDate(endParts[0]);&#10;            String endTime = endParts[1];&#10;&#10;            List&lt;StockData&gt; rangeData = getDataInRange(startDate, startTime, endDate, endTime);&#10;            if (!rangeData.isEmpty()) {&#10;                double open = rangeData.get(0).open;&#10;                double high = rangeData.stream().mapToDouble(d -&gt; d.high).max().getAsDouble();&#10;                double low = rangeData.stream().mapToDouble(d -&gt; d.low).min().getAsDouble();&#10;                double close = rangeData.get(rangeData.size() - 1).close;&#10;                long volume = rangeData.stream().mapToLong(d -&gt; d.volume).sum();&#10;&#10;                outputArea.setText(&quot;彙總結果:\n開盤價: &quot; + open + &quot;\n最高價: &quot; + high + &quot;\n最低價: &quot; + low + &quot;\n收盤價: &quot; + close + &quot;\n成交量: &quot; + volume);&#10;                currentQueryResults = rangeData; // For export, keep full list&#10;                displayData(rangeData); // Display full list in table&#10;            } else {&#10;                outputArea.setText(&quot;範圍內沒有資料&quot;);&#10;            }&#10;        }&#10;    }&#10;&#10;    // Helper to get data in time range (assuming single day for simplicity, extend if needed)&#10;    private List&lt;StockData&gt; getDataInRange(String startDate, String startTime, String endDate, String endTime) {&#10;        List&lt;StockData&gt; results = new ArrayList&lt;&gt;();&#10;        if (!startDate.equals(endDate)) {&#10;            // For multi-day, but for simplicity, assume same day or handle sequentially&#10;            // Implement multi-day if needed, but query implies same date&#10;            return results; // Placeholder, extend as per need&#10;        }&#10;        List&lt;StockData&gt; dayData = dataMap.get(startDate);&#10;        if (dayData != null) {&#10;            boolean started = false;&#10;            for (StockData data : dayData) {&#10;                if (!started &amp;&amp; data.time.compareTo(startTime) &gt;= 0) {&#10;                    started = true;&#10;                }&#10;                if (started) {&#10;                    results.add(data);&#10;                    if (data.time.compareTo(endTime) &gt; 0) {&#10;                        results.remove(results.size() - 1); // Exclude if beyond&#10;                        break;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return results;&#10;    }&#10;&#10;    // Display list in table&#10;    private void displayData(List&lt;StockData&gt; data) {&#10;        tableModel.setRowCount(0);&#10;        outputArea.setText(&quot;&quot;);&#10;        if (data != null) {&#10;            for (StockData d : data) {&#10;                tableModel.addRow(new Object[]{d.symbol, d.date, d.time, d.open, d.high, d.low, d.close, d.volume});&#10;            }&#10;            currentQueryResults = data;&#10;        }&#10;    }&#10;&#10;    // Function 7: Export to CSV (all fields for now, can add selection later)&#10;    class ExportListener implements ActionListener {&#10;        @Override&#10;        public void actionPerformed(ActionEvent e) {&#10;            if (currentQueryResults.isEmpty()) {&#10;                JOptionPane.showMessageDialog(null, &quot;沒有資料可以匯出&quot;);&#10;                return;&#10;            }&#10;            JFileChooser fc = new JFileChooser();&#10;            if (fc.showSaveDialog(null) == JFileChooser.APPROVE_OPTION) {&#10;                File file = fc.getSelectedFile();&#10;                try (BufferedWriter bw = new BufferedWriter(new FileWriter(file))) {&#10;                    bw.write(&quot;Symbol,Date,Time,Open,High,Low,Close,Volume\n&quot;);&#10;                    for (StockData d : currentQueryResults) {&#10;                        bw.write(d.toString() + &quot;\n&quot;);&#10;                    }&#10;                    JOptionPane.showMessageDialog(null, &quot;匯出成功！&quot;);&#10;                } catch (IOException ex) {&#10;                    JOptionPane.showMessageDialog(null, &quot;匯出時發生錯誤: &quot; + ex.getMessage());&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        SwingUtilities.invokeLater(StockDataProcessor::new);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>