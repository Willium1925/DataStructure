<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/D0728/grok/RestaurantSimulation.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/D0728/grok/RestaurantSimulation.java" />
              <option name="originalContent" value="package D0728.grok;&#10;&#10;import javax.swing.*;&#10;import java.awt.*;&#10;import java.util.*;&#10;import java.util.List;&#10;import java.util.concurrent.ConcurrentLinkedQueue;&#10;&#10;public class RestaurantSimulation extends JFrame {&#10;    private static final int NUM_TABLES = 6;&#10;    private static final int TABLE_SIZE = 100;&#10;    private static final int PANEL_WIDTH = 1000;&#10;    private static final int PANEL_HEIGHT = 700;&#10;    private static final int STAFF_SIZE = 30;&#10;    private final ConcurrentLinkedQueue&lt;Order&gt; orderQueue = new ConcurrentLinkedQueue&lt;&gt;();&#10;    private final ArrayList&lt;Table&gt; tables = new ArrayList&lt;&gt;();&#10;    private final JTextArea logArea;&#10;    private volatile boolean running = true;&#10;    private final List&lt;Staff&gt; deliveryStaff = new ArrayList&lt;&gt;();&#10;    private final Object deliveryLock = new Object(); // 添加同步锁&#10;&#10;    public RestaurantSimulation() {&#10;        setTitle(&quot;餐廳模擬系統&quot;);&#10;        setSize(PANEL_WIDTH, PANEL_HEIGHT);&#10;        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#10;        setLayout(new BorderLayout());&#10;&#10;        // Restaurant panel for tables, orders, and staff&#10;        JPanel restaurantPanel = new JPanel() {&#10;            @Override&#10;            protected void paintComponent(Graphics g) {&#10;                super.paintComponent(g);&#10;                Graphics2D g2d = (Graphics2D) g;&#10;                g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);&#10;                g2d.setFont(new Font(&quot;Microsoft JhengHei&quot;, Font.PLAIN, 14));&#10;&#10;                // Draw tables&#10;                for (Table table : tables) {&#10;                    // Draw table (dark if occupied, light if empty)&#10;                    g2d.setColor(table.isOccupied() ? new Color(139, 69, 19) : new Color(210, 180, 140));&#10;                    g2d.fillOval(table.x, table.y, TABLE_SIZE, TABLE_SIZE);&#10;                    g2d.setColor(Color.BLACK);&#10;                    g2d.drawString(&quot;桌號 &quot; + table.id, table.x + 20, table.y + TABLE_SIZE / 2);&#10;&#10;                    // Draw order next to table&#10;                    if (table.isOccupied() &amp;&amp; table.order != null) {&#10;                        int yOffset = table.y;&#10;                        g2d.setColor(Color.BLACK);&#10;                        g2d.drawString(&quot;訂單:&quot;, table.x + TABLE_SIZE + 20, yOffset);&#10;                        yOffset += 25;&#10;                        for (String item : table.order.items) {&#10;                            g2d.setColor(table.order.deliveredItems.contains(item) ? Color.GREEN : Color.BLACK);&#10;                            g2d.drawString(&quot;- &quot; + item, table.x + TABLE_SIZE + 30, yOffset);&#10;                            yOffset += 20;&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Draw staff&#10;                for (Staff staff : deliveryStaff) {&#10;                    g2d.setColor(Color.BLUE);&#10;                    g2d.fillOval(staff.x, staff.y, STAFF_SIZE, STAFF_SIZE);&#10;                    g2d.setColor(Color.WHITE);&#10;                    g2d.drawString(&quot;送餐員 &quot; + staff.id, staff.x + 5, staff.y + STAFF_SIZE / 2);&#10;                }&#10;            }&#10;        };&#10;        restaurantPanel.setPreferredSize(new Dimension(PANEL_WIDTH - 300, PANEL_HEIGHT));&#10;        add(restaurantPanel, BorderLayout.CENTER);&#10;&#10;        // Log area&#10;        logArea = new JTextArea(20, 25);&#10;        logArea.setFont(new Font(&quot;Microsoft JhengHei&quot;, Font.PLAIN, 14));&#10;        logArea.setEditable(false);&#10;        JScrollPane logScrollPane = new JScrollPane(logArea);&#10;        logScrollPane.setPreferredSize(new Dimension(300, PANEL_HEIGHT));&#10;        add(logScrollPane, BorderLayout.EAST);&#10;&#10;        // End button&#10;        JButton endButton = new JButton(&quot;結束模擬&quot;);&#10;        endButton.setFont(new Font(&quot;Microsoft JhengHei&quot;, Font.BOLD, 16));&#10;        endButton.addActionListener(e -&gt; {&#10;            running = false;&#10;            logArea.append(&quot;模擬已由使用者終止。\n&quot;);&#10;        });&#10;        JPanel buttonPanel = new JPanel();&#10;        buttonPanel.add(endButton);&#10;        add(buttonPanel, BorderLayout.NORTH);&#10;&#10;        // Initialize tables&#10;        for (int i = 0; i &lt; NUM_TABLES; i++) {&#10;            int row = i / 3;&#10;            int col = i % 3;&#10;            int x = 50 + col * (TABLE_SIZE + 150);&#10;            int y = 50 + row * (TABLE_SIZE + 150);&#10;            tables.add(new Table(i + 1, x, y));&#10;        }&#10;&#10;        // Initialize 3 delivery staff at kitchen&#10;        for (int i = 0; i &lt; 3; i++) {&#10;            deliveryStaff.add(new Staff(i + 1, 10, 10 + i * 40));&#10;        }&#10;&#10;        // Start simulation threads&#10;        new Thread(this::generateOrders).start();&#10;        new Thread(this::processOrders).start();&#10;        for (int i = 0; i &lt; 3; i++) {&#10;            int staffId = i;&#10;            new Thread(() -&gt; deliverOrders(staffId)).start();&#10;        }&#10;        new Thread(this::repaintLoop).start();&#10;    }&#10;&#10;    /**&#10;     * 訂單生成執行緒的主要邏輯&#10;     * 隨機生成新的訂單並分配給空閒的桌子&#10;     */&#10;    private void generateOrders() {&#10;        Random rand = new Random();&#10;        String[] menu = {&quot;漢堡&quot;, &quot;披薩&quot;, &quot;沙拉&quot;, &quot;義大利麵&quot;, &quot;牛排&quot;};&#10;        while (running) {&#10;            try {&#10;                // 隨機延遲2-5秒生成新訂單&#10;                Thread.sleep(rand.nextInt(3000) + 2000);&#10;                &#10;                // 隨機選擇一張桌子&#10;                Table table = tables.get(rand.nextInt(NUM_TABLES));&#10;                if (!table.isOccupied()) {&#10;                    // 如果桌子空閒，創建新訂單&#10;                    table.setOccupied(true);&#10;                    Order order = new Order(table.id);&#10;                    &#10;                    // 隨機生成1-3個餐點&#10;                    int numItems = rand.nextInt(3) + 1;&#10;                    for (int j = 0; j &lt; numItems; j++) {&#10;                        order.addItem(menu[rand.nextInt(menu.length)]);&#10;                    }&#10;                    &#10;                    // 將訂單分配給桌子並加入處理佇列&#10;                    table.order = order;&#10;                    orderQueue.offer(order);&#10;                    logArea.append(&quot;桌號 &quot; + table.id + &quot; 提交訂單: &quot; + order.items + &quot;\n&quot;);&#10;                }&#10;            } catch (InterruptedException e) {&#10;                Thread.currentThread().interrupt();&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 訂單處理執行緒的主要邏輯&#10;     * 負責處理佇列中的訂單，逐一製作每個餐點&#10;     */&#10;    private void processOrders() {&#10;        Random rand = new Random();&#10;        while (running) {&#10;            try {&#10;                // 查看佇列中的第一個訂單（不移除）&#10;                Order order = orderQueue.peek();&#10;                if (order != null) {&#10;                    // 處理訂單中每個尚未完成的餐點&#10;                    for (String item : order.items) {&#10;                        if (!order.preparedItems.get(item)) {&#10;                            logArea.append(&quot;正在處理桌號 &quot; + order.tableId + &quot; 的單點: &quot; + item + &quot;\n&quot;);&#10;                            // 模擬餐點製作時間（2-5秒）&#10;                            Thread.sleep(rand.nextInt(3000) + 2000);&#10;                            // 標記餐點為已完成&#10;                            order.preparedItems.put(item, true);&#10;                            logArea.append(&quot;桌號 &quot; + order.tableId + &quot; 的單點已準備完成: &quot; + item + &quot;\n&quot;);&#10;                        }&#10;                    }&#10;&#10;                    // 當訂單中所有餐點都製作完成時，將訂單從佇列中移除&#10;                    if (order.preparedItems.values().stream().allMatch(prepared -&gt; prepared)) {&#10;                        orderQueue.poll();&#10;                    }&#10;                }&#10;                // 每秒檢查一次新訂單&#10;                Thread.sleep(1000);&#10;            } catch (InterruptedException e) {&#10;                Thread.currentThread().interrupt();&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 送餐員執行緒的主要邏輯&#10;     * 每個送餐員都是一個獨立的執行緒，負責尋找並送達準備好的餐點&#10;     * &#10;     * @param staffId 送餐員編號&#10;     */&#10;    private void deliverOrders(int staffId) {&#10;        Random rand = new Random();&#10;        Staff staff = deliveryStaff.get(staffId);&#10;&#10;        while (running) {&#10;            try {&#10;                // 檢查送餐員是否可用&#10;                if (staff.isAvailable) {&#10;                    Table targetTable = null;    // 目標桌號&#10;                    String itemToDeliver = null; // 待送餐點&#10;&#10;                    // 使用同步鎖來安全地查找和認領待送的餐點&#10;                    // 確保同一時間只有一個送餐員可以認領餐點，避免重複送餐&#10;                    synchronized (deliveryLock) {&#10;                        // 遍歷所有桌子尋找需要送餐的訂單&#10;                        for (Table table : tables) {&#10;                            // 檢查桌子是否有未完成的訂單&#10;                            if (table.order != null &amp;&amp; !table.order.isDelivered) {&#10;                                Order order = table.order;&#10;&#10;                                // 在這個訂單中尋找第一個已準備好但未送達的餐點&#10;                                for (String item : order.items) {&#10;                                    // 檢查餐點是否已準備好且未送達&#10;                                    if (order.preparedItems.get(item) &amp;&amp; !order.deliveredItems.contains(item)) {&#10;                                        targetTable = table;&#10;                                        itemToDeliver = item;&#10;                                        // 立即標記為已送達，防止其他送餐員重複送餐&#10;                                        order.deliveredItems.add(item);&#10;                                        break;&#10;                                    }&#10;                                }&#10;                                // 如果找到了要送的餐點就停止搜尋&#10;                                if (targetTable != null) break;&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    // 如果找到了需要送的餐點，開始送餐流程&#10;                    if (targetTable != null &amp;&amp; itemToDeliver != null) {&#10;                        staff.isAvailable = false; // 標記送餐員為忙碌狀態&#10;                        Table table = targetTable;&#10;&#10;                        // 移動送餐員到目標桌子&#10;                        moveStaffTo(staff, table.x + TABLE_SIZE / 2, table.y + TABLE_SIZE / 2);&#10;                        logArea.append(&quot;送餐員 &quot; + staff.id + &quot; 前往桌號 &quot; + table.id + &quot; 送餐\n&quot;);&#10;&#10;                        // 送餐過程&#10;                        Thread.sleep(500); // 模擬送餐時間&#10;                        logArea.append(&quot;送餐員 &quot; + staff.id + &quot; 送達桌號 &quot; + table.id + &quot; 的單點: &quot; + itemToDeliver + &quot;\n&quot;);&#10;&#10;                        // 再次使用同步鎖檢查訂單狀態&#10;                        synchronized (deliveryLock) {&#10;                            // 檢查該桌的所有餐點是否都已送達&#10;                            if (table.order.deliveredItems.size() == table.order.items.size()) {&#10;                                table.order.isDelivered = true;&#10;                                // 啟動新執行緒在一段時間後清空桌子&#10;                                new Thread(() -&gt; {&#10;                                    try {&#10;                                        // 隨機等待 5-10 秒後清空桌子&#10;                                        Thread.sleep(rand.nextInt(5000) + 5000);&#10;                                        table.clearTable();&#10;                                        logArea.append(&quot;桌號 &quot; + table.id + &quot; 已清空。\n&quot;);&#10;                                    } catch (InterruptedException e) {&#10;                                        Thread.currentThread().interrupt();&#10;                                    }&#10;                                }).start();&#10;                            }&#10;                        }&#10;&#10;                        // 送餐員返回廚房&#10;                        moveStaffTo(staff, 10, 10 + staffId * 40);&#10;                        logArea.append(&quot;送餐員 &quot; + staff.id + &quot; 返回廚房\n&quot;);&#10;                        staff.isAvailable = true; // 標記送餐員為可用狀態&#10;                    }&#10;                }&#10;                // 短暫休息後繼續檢查新的可送餐點&#10;                Thread.sleep(500);&#10;            } catch (InterruptedException e) {&#10;                Thread.currentThread().interrupt();&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 送餐員移動動畫的實現方法&#10;     * 將送餐員從當前位置平滑移動到目標位置&#10;     * &#10;     * @param staff 要移動的送餐員&#10;     * @param targetX 目標X座標&#10;     * @param targetY 目標Y座標&#10;     */&#10;    private void moveStaffTo(Staff staff, int targetX, int targetY) {&#10;        int steps = 20; // 移動的步數，越多移動越平滑&#10;        int startX = staff.x;&#10;        int startY = staff.y;&#10;        // 計算每步移動的距離&#10;        int dx = (targetX - startX) / steps;&#10;        int dy = (targetY - startY) / steps;&#10;        &#10;        // 分步移動送餐員&#10;        for (int i = 0; i &lt;= steps; i++) {&#10;            staff.x = startX + dx * i;&#10;            staff.y = startY + dy * i;&#10;            try {&#10;                Thread.sleep(50); // 每步暫停50毫秒實現平滑移動效果&#10;            } catch (InterruptedException e) {&#10;                Thread.currentThread().interrupt();&#10;            }&#10;        }&#10;        // 確保最後位置準確&#10;        staff.x = targetX;&#10;        staff.y = targetY;&#10;    }&#10;&#10;    private void repaintLoop() {&#10;        while (running) {&#10;            try {&#10;                SwingUtilities.invokeLater(() -&gt; getContentPane().repaint());&#10;                Thread.sleep(100); // Repaint every 100ms for smooth animation&#10;            } catch (InterruptedException e) {&#10;                Thread.currentThread().interrupt();&#10;            }&#10;        }&#10;    }&#10;&#10;    private class Table {&#10;        int id;&#10;        int x, y;&#10;        private boolean occupied = false;&#10;        private Order order;&#10;&#10;        Table(int id, int x, int y) {&#10;            this.id = id;&#10;            this.x = x;&#10;            this.y = y;&#10;        }&#10;&#10;        boolean isOccupied() {&#10;            return occupied;&#10;        }&#10;&#10;        void setOccupied(boolean occupied) {&#10;            this.occupied = occupied;&#10;        }&#10;&#10;        void clearTable() {&#10;            order = null;&#10;            occupied = false;&#10;        }&#10;    }&#10;&#10;    private class Order {&#10;        int tableId;&#10;        ArrayList&lt;String&gt; items = new ArrayList&lt;&gt;();&#10;        ArrayList&lt;String&gt; deliveredItems = new ArrayList&lt;&gt;();&#10;        Map&lt;String, Boolean&gt; preparedItems = new HashMap&lt;&gt;();&#10;        boolean isDelivered = false;&#10;&#10;        Order(int tableId) {&#10;            this.tableId = tableId;&#10;        }&#10;&#10;        void addItem(String item) {&#10;            items.add(item);&#10;            preparedItems.put(item, false);&#10;        }&#10;&#10;        boolean hasUndeliveredPreparedItems() {&#10;            return items.stream()&#10;                .anyMatch(item -&gt; preparedItems.get(item) &amp;&amp; !deliveredItems.contains(item));&#10;        }&#10;    }&#10;&#10;    private class Staff {&#10;        int id;&#10;        int x, y;&#10;        boolean isAvailable = true;&#10;&#10;        Staff(int id, int x, int y) {&#10;            this.id = id;&#10;            this.x = x;&#10;            this.y = y;&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            RestaurantSimulation sim = new RestaurantSimulation();&#10;            sim.setVisible(true);&#10;        });&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package D0728.grok;&#10;&#10;import javax.swing.*;&#10;import java.awt.*;&#10;import java.util.*;&#10;import java.util.List;&#10;import java.util.concurrent.ConcurrentLinkedQueue;&#10;&#10;public class RestaurantSimulation extends JFrame {&#10;    private static final int NUM_TABLES = 6;&#10;    private static final int TABLE_SIZE = 100;&#10;    private static final int PANEL_WIDTH = 1000;&#10;    private static final int PANEL_HEIGHT = 700;&#10;    private static final int STAFF_SIZE = 30;&#10;    private final ConcurrentLinkedQueue&lt;Order&gt; orderQueue = new ConcurrentLinkedQueue&lt;&gt;();&#10;    private final ArrayList&lt;Table&gt; tables = new ArrayList&lt;&gt;();&#10;    private final JTextArea logArea;&#10;    private volatile boolean running = true;&#10;    private final List&lt;Staff&gt; deliveryStaff = new ArrayList&lt;&gt;();&#10;    private final Object deliveryLock = new Object(); // 添加同步锁&#10;&#10;    public RestaurantSimulation() {&#10;        setTitle(&quot;餐廳模擬系統&quot;);&#10;        setSize(PANEL_WIDTH, PANEL_HEIGHT);&#10;        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#10;        setLayout(new BorderLayout());&#10;&#10;        // Restaurant panel for tables, orders, and staff&#10;        JPanel restaurantPanel = new JPanel() {&#10;            @Override&#10;            protected void paintComponent(Graphics g) {&#10;                super.paintComponent(g);&#10;                Graphics2D g2d = (Graphics2D) g;&#10;                g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);&#10;                g2d.setFont(new Font(&quot;Microsoft JhengHei&quot;, Font.PLAIN, 14));&#10;&#10;                // Draw tables&#10;                for (Table table : tables) {&#10;                    // Draw table (dark if occupied, light if empty)&#10;                    g2d.setColor(table.isOccupied() ? new Color(139, 69, 19) : new Color(210, 180, 140));&#10;                    g2d.fillOval(table.x, table.y, TABLE_SIZE, TABLE_SIZE);&#10;                    g2d.setColor(Color.BLACK);&#10;                    g2d.drawString(&quot;桌號 &quot; + table.id, table.x + 20, table.y + TABLE_SIZE / 2);&#10;&#10;                    // Draw order next to table&#10;                    if (table.isOccupied() &amp;&amp; table.order != null) {&#10;                        int yOffset = table.y;&#10;                        g2d.setColor(Color.BLACK);&#10;                        g2d.drawString(&quot;訂單:&quot;, table.x + TABLE_SIZE + 20, yOffset);&#10;                        yOffset += 25;&#10;                        for (String item : table.order.items) {&#10;                            g2d.setColor(table.order.deliveredItems.contains(item) ? Color.GREEN : Color.BLACK);&#10;                            g2d.drawString(&quot;- &quot; + item, table.x + TABLE_SIZE + 30, yOffset);&#10;                            yOffset += 20;&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Draw staff&#10;                for (Staff staff : deliveryStaff) {&#10;                    g2d.setColor(Color.BLUE);&#10;                    g2d.fillOval(staff.x, staff.y, STAFF_SIZE, STAFF_SIZE);&#10;                    g2d.setColor(Color.WHITE);&#10;                    g2d.drawString(&quot;送餐員 &quot; + staff.id, staff.x + 5, staff.y + STAFF_SIZE / 2);&#10;                }&#10;            }&#10;        };&#10;        restaurantPanel.setPreferredSize(new Dimension(PANEL_WIDTH - 300, PANEL_HEIGHT));&#10;        add(restaurantPanel, BorderLayout.CENTER);&#10;&#10;        // Log area&#10;        logArea = new JTextArea(20, 25);&#10;        logArea.setFont(new Font(&quot;Microsoft JhengHei&quot;, Font.PLAIN, 14));&#10;        logArea.setEditable(false);&#10;        JScrollPane logScrollPane = new JScrollPane(logArea);&#10;        logScrollPane.setPreferredSize(new Dimension(300, PANEL_HEIGHT));&#10;        add(logScrollPane, BorderLayout.EAST);&#10;&#10;        // End button&#10;        JButton endButton = new JButton(&quot;結束模擬&quot;);&#10;        endButton.setFont(new Font(&quot;Microsoft JhengHei&quot;, Font.BOLD, 16));&#10;        endButton.addActionListener(e -&gt; {&#10;            running = false;&#10;            logArea.append(&quot;模擬已由使用者終止。\n&quot;);&#10;        });&#10;        JPanel buttonPanel = new JPanel();&#10;        buttonPanel.add(endButton);&#10;        add(buttonPanel, BorderLayout.NORTH);&#10;&#10;        // Initialize tables&#10;        for (int i = 0; i &lt; NUM_TABLES; i++) {&#10;            int row = i / 3;&#10;            int col = i % 3;&#10;            int x = 50 + col * (TABLE_SIZE + 150);&#10;            int y = 50 + row * (TABLE_SIZE + 150);&#10;            tables.add(new Table(i + 1, x, y));&#10;        }&#10;&#10;        // Initialize 3 delivery staff at kitchen&#10;        for (int i = 0; i &lt; 3; i++) {&#10;            deliveryStaff.add(new Staff(i + 1, 10, 10 + i * 40));&#10;        }&#10;&#10;        // Start simulation threads&#10;        new Thread(this::generateOrders).start();&#10;        new Thread(this::processOrders).start();&#10;        for (int i = 0; i &lt; 3; i++) {&#10;            int staffId = i;&#10;            new Thread(() -&gt; deliverOrders(staffId)).start();&#10;        }&#10;        new Thread(this::repaintLoop).start();&#10;    }&#10;&#10;    /**&#10;     * 訂單生成執行緒的主要邏輯&#10;     * 隨機生成新的訂單並分配給空閒的桌子&#10;     */&#10;    private void generateOrders() {&#10;        Random rand = new Random();&#10;        String[] menu = {&quot;漢堡&quot;, &quot;披薩&quot;, &quot;沙拉&quot;, &quot;義大利麵&quot;, &quot;牛排&quot;};&#10;        while (running) {&#10;            try {&#10;                // 隨機延遲2-5秒生成新訂單&#10;                Thread.sleep(rand.nextInt(3000) + 2000);&#10;                &#10;                // 隨機選擇一張桌子&#10;                Table table = tables.get(rand.nextInt(NUM_TABLES));&#10;                if (!table.isOccupied()) {&#10;                    // 如果桌子空閒，創建新訂單&#10;                    table.setOccupied(true);&#10;                    Order order = new Order(table.id);&#10;                    &#10;                    // 隨機生成1-3個餐點&#10;                    int numItems = rand.nextInt(3) + 1;&#10;                    for (int j = 0; j &lt; numItems; j++) {&#10;                        order.addItem(menu[rand.nextInt(menu.length)]);&#10;                    }&#10;                    &#10;                    // 將訂單分配給桌子並加入處理佇列&#10;                    table.order = order;&#10;                    orderQueue.offer(order);&#10;                    logArea.append(&quot;桌號 &quot; + table.id + &quot; 提交訂單: &quot; + order.items + &quot;\n&quot;);&#10;                }&#10;            } catch (InterruptedException e) {&#10;                Thread.currentThread().interrupt();&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 訂單處理執行緒的主要邏輯&#10;     * 負責處理佇列中的訂單，逐一製作每個餐點&#10;     */&#10;    private void processOrders() {&#10;        Random rand = new Random();&#10;        while (running) {&#10;            try {&#10;                // 查看佇列中的第一個訂單（不移除）&#10;                Order order = orderQueue.peek();&#10;                if (order != null) {&#10;                    // 處理訂單中每個尚未完成的餐點&#10;                    for (String item : order.items) {&#10;                        if (!order.preparedItems.get(item)) {&#10;                            logArea.append(&quot;正在處理桌號 &quot; + order.tableId + &quot; 的單點: &quot; + item + &quot;\n&quot;);&#10;                            // 模擬餐點製作時間（2-5秒）&#10;                            Thread.sleep(rand.nextInt(3000) + 2000);&#10;                            // 標記餐點為已完成&#10;                            order.preparedItems.put(item, true);&#10;                            logArea.append(&quot;桌號 &quot; + order.tableId + &quot; 的單點已準備完成: &quot; + item + &quot;\n&quot;);&#10;                        }&#10;                    }&#10;&#10;                    // 當訂單中所有餐點都製作完成時，將訂單從佇列中移除&#10;                    if (order.preparedItems.values().stream().allMatch(prepared -&gt; prepared)) {&#10;                        orderQueue.poll();&#10;                    }&#10;                }&#10;                // 每秒檢查一次新訂單&#10;                Thread.sleep(1000);&#10;            } catch (InterruptedException e) {&#10;                Thread.currentThread().interrupt();&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 送餐員執行緒的主要邏輯&#10;     * 每個送餐員都是一個獨立的執行緒，負責尋找並送達準備好的餐點&#10;     * &#10;     * @param staffId 送餐員編號&#10;     */&#10;    private void deliverOrders(int staffId) {&#10;        Random rand = new Random();&#10;        Staff staff = deliveryStaff.get(staffId);&#10;&#10;        while (running) {&#10;            try {&#10;                // 檢查送餐員是否可用&#10;                if (staff.isAvailable) {&#10;                    Table targetTable = null;    // 目標桌號&#10;                    String itemToDeliver = null; // 待送餐點&#10;&#10;                    // 使用同步鎖來安全地查找和認領待送的餐點&#10;                    // 確保同一時間只有一個送餐員可以認領餐點，避免重複送餐&#10;                    synchronized (deliveryLock) {&#10;                        // 遍歷所有桌子尋找需要送餐的訂單&#10;                        for (Table table : tables) {&#10;                            // 檢查桌子是否有未完成的訂單&#10;                            if (table.order != null &amp;&amp; !table.order.isDelivered) {&#10;                                Order order = table.order;&#10;&#10;                                // 在這個訂單中尋找第一個已準備好但未送達的餐點&#10;                                for (String item : order.items) {&#10;                                    // 檢查餐點是否已準備好且未送達&#10;                                    if (order.preparedItems.get(item) &amp;&amp; !order.deliveredItems.contains(item)) {&#10;                                        targetTable = table;&#10;                                        itemToDeliver = item;&#10;                                        // 立即標記為已送達，防止其他送餐員重複送餐&#10;                                        order.deliveredItems.add(item);&#10;                                        break;&#10;                                    }&#10;                                }&#10;                                // 如果找到了要送的餐點就停止搜尋&#10;                                if (targetTable != null) break;&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    // 如果找到了需要送的餐點，開始送餐流程&#10;                    if (targetTable != null &amp;&amp; itemToDeliver != null) {&#10;                        staff.isAvailable = false; // 標記送餐員為忙碌狀態&#10;                        Table table = targetTable;&#10;&#10;                        // 移動送餐員到目標桌子&#10;                        moveStaffTo(staff, table.x + TABLE_SIZE / 2, table.y + TABLE_SIZE / 2);&#10;                        logArea.append(&quot;送餐員 &quot; + staff.id + &quot; 前往桌號 &quot; + table.id + &quot; 送餐\n&quot;);&#10;&#10;                        // 送餐過程&#10;                        Thread.sleep(500); // 模擬送餐時間&#10;                        logArea.append(&quot;送餐員 &quot; + staff.id + &quot; 送達桌號 &quot; + table.id + &quot; 的單點: &quot; + itemToDeliver + &quot;\n&quot;);&#10;&#10;                        // 再次使用同步鎖檢查訂單狀態&#10;                        synchronized (deliveryLock) {&#10;                            // 檢查該桌的所有餐點是否都已送達&#10;                            if (table.order.deliveredItems.size() == table.order.items.size()) {&#10;                                table.order.isDelivered = true;&#10;                                // 啟動新執行緒在一段時間後清空桌子&#10;                                new Thread(() -&gt; {&#10;                                    try {&#10;                                        // 隨機等待 5-10 秒後清空桌子&#10;                                        Thread.sleep(rand.nextInt(5000) + 5000);&#10;                                        table.clearTable();&#10;                                        logArea.append(&quot;桌號 &quot; + table.id + &quot; 已清空。\n&quot;);&#10;                                    } catch (InterruptedException e) {&#10;                                        Thread.currentThread().interrupt();&#10;                                    }&#10;                                }).start();&#10;                            }&#10;                        }&#10;&#10;                        // 送餐員返回廚房&#10;                        moveStaffTo(staff, 10, 10 + staffId * 40);&#10;                        logArea.append(&quot;送餐員 &quot; + staff.id + &quot; 返回廚房\n&quot;);&#10;                        staff.isAvailable = true; // 標記送餐員為可用狀態&#10;                    }&#10;                }&#10;                // 短暫休息後繼續檢查新的可送餐點&#10;                Thread.sleep(500);&#10;            } catch (InterruptedException e) {&#10;                Thread.currentThread().interrupt();&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 送餐員移動動畫的實現方法&#10;     * 將送餐員從當前位置平滑移動到目標位置&#10;     * &#10;     * @param staff 要移動的送餐員&#10;     * @param targetX 目標X座標&#10;     * @param targetY 目標Y座標&#10;     */&#10;    private void moveStaffTo(Staff staff, int targetX, int targetY) {&#10;        int steps = 20; // 移動的步數，越多移動越平滑&#10;        int startX = staff.x;&#10;        int startY = staff.y;&#10;        // 計算每步移動的距離&#10;        int dx = (targetX - startX) / steps;&#10;        int dy = (targetY - startY) / steps;&#10;        &#10;        // 分步移動送餐員&#10;        for (int i = 0; i &lt;= steps; i++) {&#10;            staff.x = startX + dx * i;&#10;            staff.y = startY + dy * i;&#10;            try {&#10;                Thread.sleep(50); // 每步暫停50毫秒實現平滑移動效果&#10;            } catch (InterruptedException e) {&#10;                Thread.currentThread().interrupt();&#10;            }&#10;        }&#10;        // 確保最後位置準確&#10;        staff.x = targetX;&#10;        staff.y = targetY;&#10;    }&#10;&#10;    private void repaintLoop() {&#10;        while (running) {&#10;            try {&#10;                SwingUtilities.invokeLater(() -&gt; getContentPane().repaint());&#10;                Thread.sleep(100); // Repaint every 100ms for smooth animation&#10;            } catch (InterruptedException e) {&#10;                Thread.currentThread().interrupt();&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 代表餐廳中的一張桌子&#10;     * 包含桌號、位置信息以及當前的訂單狀態&#10;     */&#10;    private class Table {&#10;        int id;          // 桌號&#10;        int x, y;        // 桌子在畫面上的位置&#10;        private boolean occupied = false;  // 桌子是否有客人&#10;        private Order order;              // 當前桌子的訂單&#10;&#10;        Table(int id, int x, int y) {&#10;            this.id = id;&#10;            this.x = x;&#10;            this.y = y;&#10;        }&#10;&#10;        boolean isOccupied() {&#10;            return occupied;&#10;        }&#10;&#10;        void setOccupied(boolean occupied) {&#10;            this.occupied = occupied;&#10;        }&#10;&#10;        void clearTable() {&#10;            order = null;&#10;            occupied = false;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 代表一份訂單&#10;     * 包含訂單的所有餐點及其狀態信息&#10;     */&#10;    private class Order {&#10;        int tableId;                                    // 訂單所屬的桌號&#10;        ArrayList&lt;String&gt; items = new ArrayList&lt;&gt;();     // 訂單中的所有餐點&#10;        ArrayList&lt;String&gt; deliveredItems = new ArrayList&lt;&gt;();  // 已送達的餐點&#10;        Map&lt;String, Boolean&gt; preparedItems = new HashMap&lt;&gt;();  // 餐點準備狀態&#10;        boolean isDelivered = false;                    // 整份訂單是否已送完&#10;&#10;        Order(int tableId) {&#10;            this.tableId = tableId;&#10;        }&#10;&#10;        /**&#10;         * 添加一個餐點到訂單中&#10;         * @param item 要添加的餐點名稱&#10;         */&#10;        void addItem(String item) {&#10;            items.add(item);&#10;            preparedItems.put(item, false);  // 初始狀態為未準備&#10;        }&#10;&#10;        /**&#10;         * 檢查訂單中是否有已準備好但未送達的餐點&#10;         * @return 如果有未送達的已準備餐點則返回true&#10;         */&#10;        boolean hasUndeliveredPreparedItems() {&#10;            return items.stream()&#10;                .anyMatch(item -&gt; preparedItems.get(item) &amp;&amp; !deliveredItems.contains(item));&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 代表一位送餐員&#10;     * 包含送餐員的狀態和位置信息&#10;     */&#10;    private class Staff {&#10;        int id;                     // 送餐員編號&#10;        int x, y;                   // 送餐員當前位置&#10;        boolean isAvailable = true; // 送餐員是否可接受新的送餐任務&#10;&#10;        Staff(int id, int x, int y) {&#10;            this.id = id;&#10;            this.x = x;&#10;            this.y = y;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 主程式入口&#10;     * 使用 SwingUtilities.invokeLater 確保在 EDT 中創建和顯示 GUI&#10;     */&#10;    public static void main(String[] args) {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            RestaurantSimulation sim = new RestaurantSimulation();&#10;            sim.setVisible(true);&#10;        });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>